### 23.01.17
#### 1110.c(더하기 사이클)  
로직:입력 받은 수를 십의자리, 일의자리로 분리하고 분리한 두 수를 더한다. 더한 값에서 다시 일의자리를 분리해내어, 이 분리한 수들을 가지고 덧셈을 하는 과정.  

예시:26. 2+6=8, 6+8=14, 8+4=12, 4+2=6, 26(처음 입력한 값과 동일->stop)  

소감:처음 내가 생각한 로직은 입력받을 때 애초에 두 수를 (26을 입력받는다고 한다면 2, 6을 나누어 입력해줌)입력 해준다는 것이었는데, 문제 풀이에 어려움을 겪어서 질문게시판의 로직 질문을 보고 힌트를 얻어 풀었다.  

아래 코드는 내가 처음 생각한 로직이다.  

```
#include<stdio.h>

int main(){
    int a,b,c,count=0;
    scanf("%d%d",&a,&b);
    int n=a*10 + b;
    while(1){
        c=(a+b)%10;
        a=b;
        b=c;
        count++;

    if(a==n/10 && b==n%10){
        break;
        }
    }
    printf("%d",count);
}
```

이렇게 풀어도 될 것 같은데 시간초과 떠서 질문게시판에 질문 남기려고 다시 생각해보니까, 문제 입력조건이 0이상 99이하이다.  
즉 나는 애초에 두 자리수 입력만을 기준으로 생각한 것이다.  
그런데 컴파일해서 두 수를 입력하면 입력하는 수가 한 자리가 아닌 이상 결과값이 나와야하지 않나? -> 그래서 다시 질문게시판에 글을 작성했다.  


#### 10807.c 개수 세기  
문제: 첫 째 줄에 배열의 개수를 입력 받고, 둘 째 줄에 배열의 원소를 입력하고, 셋 째 줄에 배열 안에서 찾고자 하는 원소를 입력한다. 출력결과는 찾고자 하는 원소가 배열 안에 존재할 때 그 개수를 출력한다.  

예시:  
11  
1 4 1 2 4 2 4 3 4 4  
1  
출력결과) 2  

소감:
```
    for(int i=0; i<n; i++){
        scanf("%d",&arr[i]);
    }
 ```  
다음과 같이 for문을 통해서도 배열에 입력을 받을 수 있다는 것을 알게 되었다. (이때 n은 젤 처음 입력해준 배열의 개수)이다.  


#### 10871.c  
로직:배열 안의 원소를 for문을 통하여 입력받고, 주어진 수보다 작은지 비교한다.  

예시:  
10 5  
1 10 4 9 2 3 8 5 7 6  
출력결과) 1 4 2 3  

소감:입력조건에서 수열a를 이루는 정수의 개수가 n개 라고 하였고, 이 정수 n은 1이상 10,000이하이므로 배열의 크기를 a[10000]로 설정해주었다.  


#### 108018.c  
로직:입력한 배열에서, min,max값을 배열의 첫 번째로 설정하고 이후 반복문을 통해 min값 보다 작은 값이 들어오면 min값을 바꿔준다. max값 보다 큰 값이 들어오면 max값을 변경한다.  

예시:  
5  
20 10 35 30 7  
출력결과)7 35  

완성한 코드(해결):

```
#include <stdio.h>

int main(){
    int n,min,max;
    int num[1000000];
    scanf("%d",&n);
    for(int i=0; i<n; i++){
        scanf("%d",&num[i]);
    } 

    min=num[0];
    max=num[0];
    for(int i=1; i<n; i++){
        if(min>num[i]){ 
            min=num[i];
        }
        else if(max<num[i]){
            max=num[i];
        }
    }    
    printf("%d %d",min,max);
}
```

소감:처음에 내가 생각한 로직은-> [배열에 원소가 들어오면 우선 두 수를 비교하고, 큰 값과 작은 값을 설정해준다. 이후에 비교 할 원소가, 이미 담겨있는 큰 값보다 더 크면 그 값으로 값을 변경하고, 비교 할 원소가 이미 담겨있는 작은 값보다 더 작으면 그 값으로 값을 변경한다.]이다.  
이러한 로직대로라면, 입력 해주는 값이 한 개일 때 문제가 생긴다는 것을 알았다.(처음에 두 값을 비교해주어야 하는데 값이 하나뿐이므로)  
그리고 내가 처음 생각한 로직대로 코드를 작성했음에도 불구하고 배열의 전체값을 비교하는 것이 아니라,, 두 값만을 비교하기 때문에 틀렸었다.  
(예를들어 20 10 35 30 7을 입력하면 20,10 비교 후 10 35 비교하고 35 30 비교하는 식의 ...)  

