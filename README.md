## 이 파일은 모든 하위 폴더의 README 파일을 모아놓은 파일입니다.  

### 23.01.17
#### 1110.c(더하기 사이클)  
로직:입력 받은 수를 십의자리, 일의자리로 분리하고 분리한 두 수를 더한다. 더한 값에서 다시 일의자리를 분리해내어, 이 분리한 수들을 가지고 덧셈을 하는 과정.  

예시:26. 2+6=8, 6+8=14, 8+4=12, 4+2=6, 26(처음 입력한 값과 동일->stop)  

소감:처음 내가 생각한 로직은 입력받을 때 애초에 두 수를 (26을 입력받는다고 한다면 2, 6을 나누어 입력해줌)입력 해준다는 것이었는데, 문제 풀이에 어려움을 겪어서 질문게시판의 로직 질문을 보고 힌트를 얻어 풀었다.  

아래 코드는 내가 처음 생각한 로직이다.  

```
#include<stdio.h>

int main(){
    int a,b,c,count=0;
    scanf("%d%d",&a,&b);
    int n=a*10 + b;
    while(1){
        c=(a+b)%10;
        a=b;
        b=c;
        count++;

    if(a==n/10 && b==n%10){
        break;
        }
    }
    printf("%d",count);
}
```

이렇게 풀어도 될 것 같은데 시간초과 떠서 질문게시판에 질문 남기려고 다시 생각해보니까, 문제 입력조건이 0이상 99이하이다.  
즉 나는 애초에 두 자리수 입력만을 기준으로 생각한 것이다.  
그런데 컴파일해서 두 수를 입력하면 입력하는 수가 한 자리가 아닌 이상 결과값이 나와야하지 않나? -> 그래서 다시 질문게시판에 글을 작성했다.  


#### 10807.c 개수 세기  
문제: 첫 째 줄에 배열의 개수를 입력 받고, 둘 째 줄에 배열의 원소를 입력하고, 셋 째 줄에 배열 안에서 찾고자 하는 원소를 입력한다. 출력결과는 찾고자 하는 원소가 배열 안에 존재할 때 그 개수를 출력한다.  

예시:  
11  
1 4 1 2 4 2 4 3 4 4  
1  
출력결과) 2  

소감:
```
    for(int i=0; i<n; i++){
        scanf("%d",&arr[i]);
    }
 ```  
다음과 같이 for문을 통해서도 배열에 입력을 받을 수 있다는 것을 알게 되었다. (이때 n은 젤 처음 입력해준 배열의 개수)이다.  


#### 10871.c  
로직:배열 안의 원소를 for문을 통하여 입력받고, 주어진 수보다 작은지 비교한다.  

예시:  
10 5  
1 10 4 9 2 3 8 5 7 6  
출력결과) 1 4 2 3  

소감:입력조건에서 수열a를 이루는 정수의 개수가 n개 라고 하였고, 이 정수 n은 1이상 10,000이하이므로 배열의 크기를 a[10000]로 설정해주었다.  


#### 108018.c  
로직:입력한 배열에서, min,max값을 배열의 첫 번째로 설정하고 이후 반복문을 통해 min값 보다 작은 값이 들어오면 min값을 바꿔준다. max값 보다 큰 값이 들어오면 max값을 변경한다.  

예시:  
5  
20 10 35 30 7  
출력결과)7 35  

완성한 코드(해결):

```
#include <stdio.h>

int main(){
    int n,min,max;
    int num[1000000];
    scanf("%d",&n);
    for(int i=0; i<n; i++){
        scanf("%d",&num[i]);
    } 

    min=num[0];
    max=num[0];
    for(int i=1; i<n; i++){
        if(min>num[i]){ 
            min=num[i];
        }
        else if(max<num[i]){
            max=num[i];
        }
    }    
    printf("%d %d",min,max);
}
```

소감:처음에 내가 생각한 로직은-> [배열에 원소가 들어오면 우선 두 수를 비교하고, 큰 값과 작은 값을 설정해준다. 이후에 비교 할 원소가, 이미 담겨있는 큰 값보다 더 크면 그 값으로 값을 변경하고, 비교 할 원소가 이미 담겨있는 작은 값보다 더 작으면 그 값으로 값을 변경한다.]이다.  
이러한 로직대로라면, 입력 해주는 값이 한 개일 때 문제가 생긴다는 것을 알았다.(처음에 두 값을 비교해주어야 하는데 값이 하나뿐이므로)  
그리고 내가 처음 생각한 로직대로 코드를 작성했음에도 불구하고 배열의 전체값을 비교하는 것이 아니라,, 두 값만을 비교하기 때문에 틀렸었다.  
(예를들어 20 10 35 30 7을 입력하면 20,10 비교 후 10 35 비교하고 35 30 비교하는 식의 ...)  

---

### 23.01.18  
#### 2562.c(최댓값)  
로직: 반복문을 통해 배열의 값들을 입력 받고, 처음 입력 받은 값을 max로 설정한다. 이후 반복문을 통해 배열 내부에 들어 있는 값과 설정한 max의 값을 비교하여 이 max보다 큰 값이 들어온다면 그 값을 max로 바꾸어 준다.  

예시:  
3  
29  
38  
12  
57  
74  
40  
85  
61  
출력결과)85 8  

소감:출력 결과에서 첫 번째로는 최댓값을 출력해야 하고, 두 번째로는 최댓값이 몇 번째 수인지를 출력해야 한다. 최댓값이 몇 번째 수인지를 출력하는 과정에서 이 수를 저장할 변수를 초기화 하지 않아 문제 해결에 어려움을 겪었다. -> 초기화 해줌으로써 문제 해결  


#### 5597.c  
로직:크기가 31인 배열을 선언하고, 배열 인덱스 자체를 출석번호로 설정한다.(1,3,5를 입력 받으면 각 1,3,5번째 인덱스에 1,3,5를 저장) 이후 배열을 0 or 특정 값으로 초기화 하고 1번 인덱스부터 차례로 검사하며 초기값이 그대로 들어 있는 요소만 출력한다.  

예시:  
3  
1  
4  
5  
7  
9  
6  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
출력결과)2 8  

소감:로직은 전반적으로 이해하겠는데 스스로 완벽하게 풀지 못한 문제이다. 질문게시판과 구글링을 통해서 정답코드와 그 로직도 참고했는데, 머릿속에서 완전히 이해하지 못했다. 그림판에 그려보면서 로직 이해하고자 했는데 그걸 코드로 구현 못함 ㄸㄹㄹ..TT 3시간 이상은 이 문제에 투자한 것 같은데 이런 실력 가지고 어떻게 운체 시프하지 눈물 날 뻔했다. 고작 브론즈 lev5문제인데  
처음 내가 생각한 로직은  
```
입력 받은 배열의 원소들을 1부터 30까지 비교해서 없으면 저장하고 그 값(미존재 값)은 min으로 설정.  
min값이 다음에 들어오는 값(두 번째 미존재 값)이랑 비교해서 작으면 그것을 min으로 바꿔주고,  
이전에 min값으로 설정해준 값은 max로 변경해서 min,max 값을 모두 출력한다.  
``` 
이었다.  그런데 마음처럼 잘 안 돼서 다음과 같이 바꾸었다.  
```
1부터 30까지의 31개의 배열을 미리 선언(배열은 0부터니까 0~30까지 총 31개의 배열필요).  
scanf로 출석번호들을 배열에 저장해놓음.  
처음 1~30까지의 배열과 출석번호가 저장된 배열의 원소를 비교.
```  
그런데 이 로직조차도 두 배열 내부 원소들을 비교하는 방법이 마땅히 떠오르지 않아서 결국 솔루션을 찾아보게 됐다.  

정답코드:  
```
#include <stdio.h>

int main(){
    int arr[31]={0};
    int num;

    for(int i=0; i<28; i++){
        scanf("%d",&num);
        arr[num]=num;
    }
    
    for(int i=1; i<31; i++){
        if(arr[i]==0){
            printf("%d\n",i);
        }
    }
}
```
---

### 23.01.19  
#### 3052.c (평균)  
로직:  
크기가 42인 배열을 생성하고 0으로 초기화 한다. (arr[42]={0})  
42로 나누었을 때 나머지가 존재하는 배열을 증가시킨다. (arr[a%42]++)  
배열의 원소가 0이 아닐 때 count를 한다. (반복문에서 arr[i]!=0 ; count+=1)  

예시:  
39  
40  
41  
42  
43  
44  
82  
83  
84  
85  
출력예시) 6  

소감:  
처음 생각한 로직은 다음과 같다.  
``` 
42로 나눈 나머지들을 배열에 담아놓는다.  
배열 중복검사해서 중복이 발생하는 경우 1씩 빼주고, 아닌경우 1씩 count한다. 
```  
이 로직대로 코드를 작성하면,  
```  

int main(){
    int arr[10]={0};
    int n;
    int count=0;

    for(int i=0; i<10; i++){
        scanf("%d",&n);
        arr[i]=n%42; //배열에 42로 나눈 나머지를 넣어준다
    }

    for(int i=0; i<10; i++){
        if(arr[i]!=-1){ //arr[i]에, 42로 나누어 떨어져서 0이 들어 있는
            count ++; //경우를 고려하여 -1로 설정하고, 값이 들어있을 때 count해준다
        }
        for(int j=i+1; j<10; j++){
            if(arr[i]==arr[j]){ // 배열 안의 원소가 동일하면
                arr[j]=-1; // -1로 만들어서 무시한다
            }
        }
    }
    printf("%d",count);
}
```  
가 된다.  

#### 1546.c (평균)  
로직:  
문제에서 제시 한 그대로 과목 개수와 시험 점수를 입력 받은후, 시험 점수의 최댓값을 구하여 이를 통해 기존의 시험 점수를 조작하고 평균을 내면 된다.  

예시:  
3 (과목 수)  
40 80 60 (시험 점수)  
출력예시) 75.0 (-> 원래점수/최댓값*100 하여 새로운 시험점수를 구하고 이의 평균을 출력함)  

소감:  
이전에 풀었던 예제들을 통해 배열을 선언하고, 최댓값을 구하였고, 조작된 시험 점수를 구했다. 이 문제의 정답은 소수점으로 출력되는데, 처음 이러한 점을 유의하지 못해서 결과가 제대로 나오지 않았다. 이후 새로운 배열을 double형으로 선언하여 해결하였다.  

---

### 23.01.20  
#### 8958.c (OX퀴즈)  

로직:  
테스트케이스 수를 입력 받고, 이후 O와 X로 이루어진 문자열을 입력받아 이를 배열에 넣는다.  
O의 경우 1점을 획득하고 X인 경우는 점수를 획득하지 않는데, 연속적으로 O가 나올 경우  
1점을 추가로 더 획득한다.  
-> 즉, for문을 통해 테스트케이스 횟수만큼 문자열OX을 배열에 입력 받고, O인 경우는 +1 X인 경우는 점수를 0으로 초기화 해준다. 점수의 총점을 출력한다.  
예시:  
5  
OOXXOXXOOO  
OOXXOOXXOO  
OXOXOXOXOXOXOX  
OOOOOOOOOO  
OOOOXOOOOXOOOOX  
출력예시) 10 9 7 55 30  

소감:  
처음 내가 생각한 로직은 배열에 O,X를 입력받고 O인 경우 +1 & 그 다음 배열이 O인지 검사하여 O라면 ++을 하여 총 점수를 구하고자 하였다. 이 로직은 구현하는 데에 어려움이 있을 것 같아, for문을 통해서 'O'인 경우에만 점수를 획득하고 변수를 하나 더 두어서 합계를 따로 구하는 방식을 선택하였다.  

완성 코드:  

```  
#include <stdio.h>

int main(){
    int n,count=0,sum=0;
    scanf("%d",&n); //테스트케이스 수 입력 

    for(int i=0; i<n; i++){ 
            char arr[81]={0};
            count=0;
            sum=0;
            scanf("%s",arr);

        for(int j=0; j<80; j++){
            if(arr[j]=='O'){
                count +=1;
                sum += count; 
            }

            else{
                count = 0;
                }            
        }
        printf("%d\n",sum);
    }
}
```  
위 코드에서 헤더파일 <string.h>를 선언하고, 문자열의 길이만큼 반복문을 실행하여 점수를 구하는 방식도 존재할테지만 헤더파일을 하나 더 선언하지 않고 코드를 작성하고 싶은 마음에 최대 80까지 입력받는 문제 조건에 의하여 반복문을 작성하였다. ``` for(int j=0; j<80; j++;)```  
더불어 배열을 초기화 해주는 ```arr[81]={0};``` 이 내용도 처음 테스트케이스의 수를 입력받는 코드 바로 아래에 작성하였었다.  

그러나 이렇게 작성하니 테스트케이스 중 'OOOOOOOOOO'을 입력 받았을 때, 55가 아닌 56이 출력 되는 문제가 발생하였다.  
이런 문제가 왜 발생하는지 궁금하여 [질문게시판](https://www.acmicpc.net/board/view/102789)을 찾아보게 되었고, 입력을 받을 때 배열 전체를 비워줘야 한다(즉 초기화 해주어야 한다)는 사실을 알게 되었다.  
이 이유는 배열을 초기화 해주지 않게 되면, 이전에 입력 받은 내용이 현재 입력 받는 문자열보다 길이가 길 경우 배열 요소에 남아있기 때문에 잘못된 출력결과가 도출될 수 있기 때문이다.  
=> 이전에 OXOXOXOXOXOXOX를 입력 받은 후 OOOOOOOOOO을 입력받게되면,
OOOOOOOOOO이 입력받아지고도 이전의 내용인 XOX가 뒤에 남아 있다.  
``` 'O','O','O','O','O','O','O','O','O','O','\0','X','O','X' ``` 
(OXOX가 남아 있는 것이 아니라 XOX가 남아있는 이유: 위처럼 문자열은 마지막 null값(\0) 을 포함하기 때문)  


